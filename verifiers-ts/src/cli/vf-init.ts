#!/usr/bin/env node

import fs from "fs";
import path from "path";

type ScaffoldOptions = {
  envName: string;
  targetDir: string;
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]+/g, " ")
    .replace(/[^\w\s]/g, "")
    .split(" ")
    .filter(Boolean)
    .map((segment) => segment[0].toUpperCase() + segment.slice(1))
    .join("");
}

function ensureEmptyDir(dir: string) {
  if (fs.existsSync(dir)) {
    if (fs.statSync(dir).isDirectory() && fs.readdirSync(dir).length === 0) {
      return;
    }
    console.error(`Target directory already exists: ${dir}`);
    process.exit(1);
  }
  fs.mkdirSync(dir, { recursive: true });
}

function writeFile(filePath: string, contents: string) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, contents, { encoding: "utf8" });
}

function createPackageJson({ envName }: ScaffoldOptions, pascalName: string): string {
  const packageJson = {
    name: envName,
    version: "0.1.0",
    type: "module",
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    scripts: {
      build: "tsc",
      "vf-eval": "node ./node_modules/verifiers-ts/dist/cli/vf-eval.js"
    },
    dependencies: {
      "verifiers-ts": "^0.0.1"
    },
    devDependencies: {
      "@types/node": "^20.0.0",
      typescript: "^5.3.0"
    },
    verifiers: {
      envId: envName,
      entry: "./dist/index.js",
      eval: {
        numExamples: 5,
        rolloutsPerExample: 1
      }
    }
  } as const;

  return `${JSON.stringify(packageJson, null, 2)}\n`;
}

function createTsConfig(): string {
  const config = {
    compilerOptions: {
      target: "ES2022",
      module: "ESNext",
      moduleResolution: "Node",
      lib: ["ES2022"],
      rootDir: "./src",
      outDir: "./dist",
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      resolveJsonModule: true,
      declaration: true,
      sourceMap: true,
      types: ["node"]
    },
    include: ["src/**/*"],
    exclude: ["dist", "node_modules"]
  } as const;

  return `${JSON.stringify(config, null, 2)}\n`;
}

function createIndexTs(envName: string, pascalName: string): string {
  return `import { Rubric, SingleTurnEnv } from "verifiers-ts";

type Example = {
  prompt: { role: "user"; content: string }[];
  answer: string;
};

const examples: Example[] = [
  {
    prompt: [{ role: "user", content: "Replace this prompt with your task." }],
    answer: "Expected answer",
  },
];

const rubric = new Rubric({
  funcs: [({ completion, answer }) => (serialize(completion).includes(answer) ? 1 : 0)],
  weights: [1],
});

function serialize(completion: unknown): string {
  if (typeof completion === "string") {
    return completion;
  }
  if (Array.isArray(completion)) {
    return completion
      .map((msg) => (typeof msg === "object" && msg && "content" in msg ? String((msg as any).content ?? "") : ""))
      .join(" ");
  }
  return "";
}

export async function create${pascalName}Environment() {
  return new SingleTurnEnv({
    envId: "${envName}",
    dataset: examples,
    systemPrompt: "Answer the question accurately.",
    rubric,
  });
}

export const loadEnvironment = create${pascalName}Environment;
`;
}

function createReadme(envName: string, pascalName: string): string {
  return `# ${pascalName} Environment

Scaffold generated by verifiers-ts. Update the prompt, dataset, and rewards to fit your task.

## Quick start

\`${envName}\` ships with basic TypeScript tooling:

\`\`\`bash
cd ${envName}
pnpm install
pnpm build
pnpm vf-eval -n 1 -r 1
\`\`\`

## Next steps

1. Replace the placeholder dataset in src/index.ts.
2. Customize the reward functions and rubric weights.
3. Add tools, multi-turn lifecycles, or custom agents as needed.
`;
}

function scaffold(options: ScaffoldOptions) {
  const pascalName = toPascalCase(options.envName);
  ensureEmptyDir(options.targetDir);

  writeFile(
    path.join(options.targetDir, "package.json"),
    createPackageJson(options, pascalName)
  );
  writeFile(path.join(options.targetDir, "tsconfig.json"), createTsConfig());
  writeFile(path.join(options.targetDir, "README.md"), createReadme(options.envName, pascalName));
  writeFile(
    path.join(options.targetDir, "src", "index.ts"),
    createIndexTs(options.envName, pascalName)
  );
}

function main() {
  const [envName] = process.argv.slice(2);
  if (!envName) {
    console.error("Usage: vf-init <env-name>");
    process.exit(1);
  }

  const safeName = envName.trim();
  if (!safeName) {
    console.error("Environment name cannot be empty");
    process.exit(1);
  }

  const targetDir = path.resolve(process.cwd(), safeName);
  scaffold({ envName: safeName, targetDir });

  console.log(`Created TypeScript environment scaffold at ${targetDir}`);
  console.log("Next steps: pnpm install && pnpm build && pnpm vf-eval -n 1 -r 1");
}

main();
